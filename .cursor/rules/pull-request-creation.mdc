---
description: Guidelines for creating comprehensive GitHub pull requests for DuckDuckGo browser, including template structure, contributor analysis, and tooling instructions. "pull request" "PR creation" "github" "code review" "git"
globs: 
alwaysApply: false
---
# GitHub Pull Request Creation Guidelines

## Overview
This rule provides guidelines for creating comprehensive pull requests for the DuckDuckGo browser codebase following the established PR template and engineering expectations.

## Quick Start (TL;DR)

**Fastest PR Creation:**
```bash
# 1. Create branch with username prefix (e.g., alex/feature-name)
git checkout -b username/feature-description origin/main

# 2. Commit and push (sets upstream automatically)
git add .
git commit -m "Brief description"
git push -u origin $(git branch --show-current)

# 3. Create PR (opens in browser for editing)
gh pr create --fill-verbose --web --label "pending ship review"
```

**Essential PR Checklist:**
- [ ] Task/Issue URL provided
- [ ] Impact level specified (High/Medium/Low)
- [ ] Testing steps included
- [ ] "pending ship review" label for UI changes
- [ ] Contributors CC'd (use `gh api repos/duckduckgo/apple-browsers/collaborators --jq '.[].login'`)

**Common Labels:** `pending ship review`, `feature`, `bug`, `performance`, `security`

## Branch Naming Convention

### Required Format: `username/feature-description`
- **Always include your username** as prefix (e.g., `alex/`, `john/`, `sarah/`)
- **Use descriptive feature names** that clearly indicate the change
- **Use hyphens** to separate words in the description
- **Keep it concise** but descriptive

**Examples:**
- `alex/delete-browsing-data-menu`
- `john/fix-bookmark-sync-crash`
- `sarah/improve-privacy-dashboard`

**Why username prefixes?**
- Prevents branch name conflicts between team members
- Makes it clear who owns each branch
- Easier to track and manage branches
- Follows DuckDuckGo team conventions

## Important Notes

### Keep It Practical
- **Go through the template systematically** but don't overcomplicate things
- **Be thorough but concise** - provide necessary information without excessive detail
- **Focus on what reviewers need to know** to evaluate your code changes
- **Remove template sections** that genuinely don't apply to your change

### Review Process Separation
- **PR Review**: Focuses on code quality, architecture, security, and functionality
- **Ship Review**: Evaluates UX impact and user-facing changes (shouldn't be in scope of the PR description)
- **UX impact evaluation is NOT part of PR review** - it happens during Ship review

### UI/Interaction Changes
- **Add "pending ship review" label** to PRs that modify:
  - User interface elements
  - User interactions or workflows  
  - Visual design or layout
  - User-facing messaging or copy
- **Ship review** will evaluate UX impact before release

## PR Template Structure

### Required Information Collection
Before creating a PR, always gather:

1. **Task/Issue URL**: MUST be provided or explicitly asked for
   - If not provided: "Please provide the Task/Issue URL for this change"
   - Should link to Asana task or GitHub issue
   
2. **Tech Design URL**: Include if one exists
   - Can be skipped if no tech design was created
   - Required if there's an existing tech design document for the change
   
3. **CC**: Contributors to modified code areas
   - Analyze git history/blame for modified files to identify key contributors
   - CC the most active contributors to the affected code areas
   - Choose the most valuable contributor as the primary reviewer

### Description Guidelines

#### Content Requirements
- **Clear and Concise**: Explain what the change does, not how it works
- **User-Focused**: Describe the benefit or problem being solved
- **Context**: Provide enough background for reviewers unfamiliar with the area
- **Screenshots/Videos**: Required only for non-obvious features/bugs or complex UI changes

#### Good Description Examples
```
# Good
Adds delete browsing data functionality to the main menu, allowing users to quickly clear their browsing history, cookies, and cache without navigating to settings.

# Bad  
Implemented the delete browsing data feature by adding new view models and UI components.
```

### Testing Steps Analysis

#### Change Type Detection
Analyze the code changes to determine appropriate testing steps:

**UI Changes**:
- Include steps for different screen sizes (iPhone, iPad, macOS)
- Test light/dark mode variations
- Verify accessibility features
- Test with different system settings (text size, etc.)
- Include screenshots/videos only for non-obvious changes or complex interactions

**Feature Changes**:
- Test happy path scenarios
- Test edge cases and error conditions
- Verify integration with existing features
- Test data persistence/clearing

**API/Service Changes**:
- Test network conditions (offline, slow connection)
- Verify error handling
- Test concurrent operations
- Validate data integrity

**Privacy/Security Changes**:
- Verify data clearing mechanisms
- Test fireproofing behavior
- Validate secure storage usage
- Test privacy dashboard updates

#### Testing Steps Format
1. **Preconditions**: What state should the app be in?
2. **Actions**: Step-by-step instructions
3. **Expected Results**: What should happen at each step
4. **Verification**: How to confirm the change works

Example:
```
1. Open DuckDuckGo browser with existing browsing history
2. Navigate to main menu ‚Üí "Clear Browsing Data"
3. Select "All Time" and check all data types
4. Tap "Clear Data" and confirm
5. Expected: All browsing data cleared, confirmation message shown
6. Verify: History tab is empty, no saved passwords remain
```

### Impact and Risk Assessment

#### Impact Level Classification
**High Impact** - Requires extra scrutiny:
- Changes to WebView handling or content blocking
- Authentication/credential management
- Data storage/clearing mechanisms
- Network security features
- Core browsing functionality

**Medium Impact**:
- New features that affect user workflows
- Settings or preferences changes
- UI/UX modifications to existing features
- Performance optimizations

**Low Impact**:
- Bug fixes for non-critical issues
- Minor UI adjustments
- Internal refactoring without behavior changes
- Documentation updates

#### Risk Analysis Questions
Always address:
- **Data Loss**: Could this change cause users to lose data?
- **Privacy**: Could this expose user information?
- **Security**: Does this introduce security vulnerabilities?
- **Performance**: Could this degrade app performance?
- **Compatibility**: Does this break existing functionality?
- **Edge Cases**: What happens in unusual scenarios?

### Quality Considerations Checklist

#### Privacy & Security Review
- [ ] No hardcoded secrets or API keys
- [ ] Sensitive data properly encrypted/stored
- [ ] User data clearing mechanisms tested
- [ ] Privacy dashboard reflects changes
- [ ] Follows fireproofing patterns if applicable

#### Performance Considerations
- [ ] Main thread not blocked by heavy operations
- [ ] Memory usage reasonable
- [ ] Network requests optimized
- [ ] UI remains responsive during operations

#### Code Quality
- [ ] Follows DuckDuckGo architecture patterns (MVVM, DI, Coordinators)
- [ ] Uses DesignResourcesKit for colors/icons
- [ ] Proper error handling implemented
- [ ] Unit tests written/updated
- [ ] No anti-patterns introduced

#### Platform Considerations
**iOS-specific**:
- [ ] Works across iPhone/iPad form factors
- [ ] Handles multitasking correctly
- [ ] Supports iOS accessibility features
- [ ] Background app refresh behavior correct

**macOS-specific**:
- [ ] Window management handled properly
- [ ] Keyboard shortcuts work as expected
- [ ] Menu bar integration correct
- [ ] System services integration proper

#### Documentation Updates
- [ ] README files updated if needed
- [ ] API documentation reflects changes
- [ ] User-facing help content updated
- [ ] Internal documentation current

### Notes to Reviewer Guidelines

#### What to Highlight
- **Complex Logic**: Explain algorithmic decisions
- **Trade-offs**: Justify chosen approaches
- **Future Work**: Note planned improvements
- **Dependencies**: Mention external factors
- **Testing Gaps**: Acknowledge limitations

#### Specific Review Requests
```
# Good Examples
- "Please pay attention to the error handling in DataClearingService - I want to ensure we don't miss any edge cases"
- "The UI animation timing might need adjustment - please test on older devices"
- "I'm unsure about the Core Data migration - please review the schema changes carefully"

# Avoid Generic Requests
- "Please review"
- "Let me know what you think"
```

## Change Analysis Prompts

When analyzing code changes, consider:

1. **Files Modified**: What components are affected?
2. **Architecture Impact**: Does this follow established patterns?
3. **Integration Points**: What other features might be affected?
4. **User Journey**: How does this change the user experience?
5. **Privacy Implications**: What data is involved?
6. **Testing Coverage**: What scenarios need verification?

### Contributor Analysis for CC and Reviewer Selection

#### Identifying Contributors
Use git commands to analyze code ownership:

```bash
# Find contributors to specific files
git log --pretty=format:"%an <%ae>" --follow -- path/to/file.swift | sort | uniq -c | sort -nr

# Find recent contributors (last 6 months)
git log --since="6 months ago" --pretty=format:"%an <%ae>" --follow -- path/to/file.swift | sort | uniq -c | sort -nr

# Find contributors to specific functions/classes
git log -L :functionName:path/to/file.swift --pretty=format:"%an <%ae>" | sort | uniq -c | sort -nr
```

#### Contributor Evaluation Criteria
**Most Valuable Contributor** (Primary Reviewer):
1. **Recent Activity**: Active in the last 3-6 months on affected files
2. **Code Ownership**: Highest commit count in modified areas
3. **Domain Expertise**: Knowledge of the specific feature/component
4. **Code Quality**: History of thorough reviews and good architectural decisions

**CC Selection**:
- Contributors with significant commits to modified files
- Original authors of major components being changed
- Subject matter experts for the feature area
- Team leads or architects if architectural changes are involved

#### Analysis Examples

**For UI Changes**:
```bash
# Find contributors to view controllers and SwiftUI views
git log --pretty=format:"%an <%ae>" --follow -- "*ViewController.swift" "*View.swift" | sort | uniq -c | sort -nr
```

**For Service/Logic Changes**:
```bash
# Find contributors to service classes and business logic
git log --pretty=format:"%an <%ae>" --follow -- "*Service.swift" "*Manager.swift" | sort | uniq -c | sort -nr
```

**For Privacy/Security Changes**:
```bash
# Find contributors to privacy-related files
git log --pretty=format:"%an <%ae>" --follow -- "*Privacy*" "*Security*" "*Fireproof*" | sort | uniq -c | sort -nr
```

#### Reviewer Selection Logic
1. **Primary Reviewer**: Choose the contributor with:
   - Most commits in the affected area (recent activity weighted higher)
   - Demonstrated expertise in the specific domain
   - History of providing quality code reviews

2. **Secondary CCs**: Include:
   - Top 2-3 contributors to modified files
   - Original authors of significantly modified components
   - Team members with domain expertise

3. **Avoid Over-CCing**: Limit to 3-5 people unless it's a major architectural change

#### Example Analysis Output
```
Modified Files Analysis:
- BrowsingMenuViewController.swift: 15 commits by @alice, 8 by @bob, 3 by @charlie
- DataClearingService.swift: 12 commits by @bob, 7 by @alice, 5 by @diana

Recommended:
- Primary Reviewer: @alice (most active across both files)
- CC: @bob (major contributor), @diana (service expert)
```

## Common Pitfalls to Avoid

### Description Pitfalls
- ‚ùå Technical implementation details instead of user benefits
- ‚ùå Vague language like "fixes issues" or "improves performance"
- ‚ùå Missing context for complex changes
- ‚ùå No mention of user-visible changes

### Testing Steps Pitfalls  
- ‚ùå Generic steps that don't test the actual change
- ‚ùå Missing edge cases and error conditions
- ‚ùå No verification of integration with existing features
- ‚ùå Incomplete testing across platforms/configurations

### Risk Assessment Pitfalls
- ‚ùå Underestimating impact on privacy or security
- ‚ùå Not considering performance implications
- ‚ùå Missing compatibility issues
- ‚ùå Inadequate consideration of edge cases

## Template Usage

Always start with the complete template and fill each section thoughtfully:

```markdown
Task/Issue URL: [REQUIRED - Ask if not provided]
Tech Design URL: [Include if one exists for this change]
CC: [Contributors identified through git analysis - limit to 3-5 people]

### Description
[Clear, user-focused description of the change]

### Testing Steps
1. [Specific, actionable steps that verify the change works]
2. [Include edge cases and error conditions]
3. [Verify integration with existing features]

### Impact and Risks
Impact Level: [High/Medium/Low/None with justification]

#### What could go wrong?
[Specific scenarios and mitigation strategies]

### Quality Considerations
[Address relevant aspects: privacy, performance, compatibility, etc.]

### Notes to Reviewer
[Specific areas needing attention or known limitations]
```

## Pre-PR Creation Checklist

Before creating the PR, complete this analysis:

1. **Gather Required Information**:
   - [ ] Task/Issue URL obtained
   - [ ] Tech Design URL checked (include if exists)
   - [ ] Git analysis completed for contributor identification

2. **Analyze Code Changes**:
   - [ ] Files modified identified and categorized
   - [ ] Impact level assessed based on change type
   - [ ] Testing scenarios planned based on change analysis
   - [ ] Privacy and security implications evaluated

3. **Identify Stakeholders**:
   - [ ] Contributors to modified files identified via git log
   - [ ] Most valuable contributor selected as primary reviewer
   - [ ] Appropriate CCs selected (3-5 people max)
   - [ ] Domain experts included if needed

4. **Prepare Content**:
   - [ ] User-focused description written
   - [ ] Comprehensive testing steps created
   - [ ] Risk scenarios identified and mitigation noted
   - [ ] Quality considerations addressed
   - [ ] Specific reviewer guidance provided

Remember: A good PR description saves reviewer time and catches issues before they reach users. Always prioritize clarity and completeness over brevity.

## Exact PR Template

Use this exact template structure when creating PRs (unless `gh` client provides it automatically):

```markdown
<!--
Note: This template is a reminder of our Engineering Expectations and Definition of Done. Remove sections that don't apply to your changes.

‚ö†Ô∏è If you're an external contributor, please file an issue before working on a PR. Discussing your changes beforehand will help ensure they align with our roadmap and that your time is well spent.
-->

Task/Issue URL:
Tech Design URL:
CC:

### Description

### Testing Steps
<!-- Assume the reviewer is unfamiliar with this part of the app -->
1.
2.

### Impact and Risks
<!-- 
What's the impact on users if something goes wrong?

High: Could affect user privacy, lose user data, break core functionality
Medium: Could disrupt specific features or user flows
Low: Minor visual changes, small bug fixes, improvement to existing features
None: Internal tooling, documentation
-->

#### What could go wrong?
<!-- Describe specific scenarios and how you've addressed them -->

### Quality Considerations
<!-- 
Focus on what matters for your changes:
- What edge cases exist?
- How does this affect performance?
- What monitoring have you added?
- What documentation needs updating?
- How does this impact privacy/security?
-->

### Notes to Reviewer
<!-- Anything specific you want reviewers to focus on -->

---
###### Internal references:
[Definition of Done](mdc:https:/app.asana.com/0/1202500774821704/1207634633537039/f) | [Engineering Expectations](mdc:https:/app.asana.com/0/59792373528535/199064865822552) | [Tech Design Template](mdc:https:/app.asana.com/0/59792373528535/184709971311943)
```

## Template Usage Notes

- **HTML Comments**: Keep all HTML comments in the template as they provide important context
- **Empty Fields**: Fill in all applicable fields based on the analysis guidance above
- **Section Removal**: Remove sections that truly don't apply, but be conservative - most sections usually have some relevant content
- **Internal References**: Keep the footer links as they provide important process documentation

## PR Creation Tooling Instructions

### Method 1: GitHub CLI (Recommended)

#### Setup
```bash
# Install GitHub CLI (if not already installed)
brew install gh

# Authenticate with GitHub
gh auth login
```

#### Streamlined PR Creation Workflow

**Option A: Direct Creation (Fastest)**
```bash
# 1. Commit and push your changes
git add .
git commit -m "Brief description of changes"
git push -u origin $(git branch --show-current)

# 2. Create PR with minimal template (GitHub CLI will use repository template)
gh pr create \
  --title "Descriptive PR Title" \
  --body "Task/Issue URL: [REQUIRED]

### Description
Brief description of changes

### Testing Steps
1. Step 1
2. Step 2

### Impact and Risks
Impact Level: Low/Medium/High - Justification

### Quality Considerations
- Key considerations

### Notes to Reviewer
- Specific reviewer guidance" \
  --label "pending ship review" \
  --web
```

**Option B: Interactive Creation (Recommended for Complex PRs)**
```bash
# 1. Commit and push your changes (sets upstream)
git add .
git commit -m "Brief description of changes"
git push -u origin $(git branch --show-current)

# 2. Create PR interactively - opens editor with template
gh pr create --fill-verbose --web

# 3. Add labels if needed
gh pr edit --add-label "pending ship review"
```

**Option C: Web-First Approach (Most Flexible)**
```bash
# 1. Commit and push your changes (sets upstream)
git add .
git commit -m "Brief description of changes"
git push -u origin $(git branch --show-current)

# 2. Open PR creation page in browser
gh pr create --web
```

#### Contributor Analysis Helpers

**Quick Contributor Lookup**
```bash
# Function to add to your shell profile (.zshrc/.bashrc)
function pr-contributors() {
    echo "=== Top Contributors to Modified Files ==="
    git diff --name-only HEAD~1 | while read file; do
        echo "--- $file ---"
        git log --pretty=format:"%an" --follow -- "$file" | sort | uniq -c | sort -nr | head -3
    done
}

# Usage: Run after committing changes
pr-contributors
```

**GitHub Username Lookup**
```bash
# Get actual GitHub usernames (not just commit names)
gh api repos/duckduckgo/apple-browsers/collaborators --jq '.[].login' | sort
```

#### Common GitHub CLI Commands

```bash
# After creating PR
gh pr edit --add-reviewer @username1,@username2
gh pr edit --add-label "feature" --add-label "bug"
gh pr edit --add-assignee @me

# Check PR status
gh pr status
gh pr view --web

# Convert to draft
gh pr ready --undo

# Mark ready for review
gh pr ready
```

### Method 2: GitHub Web Interface

#### Steps
1. **Push your branch**:
   ```bash
   git checkout -b feature/your-feature-name
   git add .
   git commit -m "Your commit message"
   git push -u origin feature/your-feature-name
   ```

2. **Open GitHub in browser**:
   - Navigate to the repository
   - Click "Compare & pull request" button
   - Or go to "Pull requests" ‚Üí "New pull request"

3. **Fill in PR details**:
   - Copy the exact template from the rule above
   - Fill in all sections based on your analysis (be thorough but concise)
   - Add reviewers and assignees
   - Set labels if needed
   - Add "pending ship review" label for UI/interaction changes

### Method 3: IDE Integration (Cursor/VS Code)

#### GitHub Extension
1. **Install GitHub PR extension** in Cursor/VS Code
2. **Sign in to GitHub** through the extension
3. **Create PR**:
   - Use Command Palette: `GitHub: Create Pull Request`
   - Fill in the template in the editor
   - Set reviewers and labels

#### Git Graph Extensions
- Use Git Graph or similar extensions to create PRs visually
- Right-click on your branch ‚Üí "Create Pull Request"

### Method 4: Command Line + Web (Hybrid)

```bash
# 1. Push branch and get PR URL
git push -u origin feature/your-feature-name

# 2. Open PR creation page directly
gh pr create --web

# 3. Or get the URL to open manually
echo "https://github.com/duckduckgo/apple-browsers/compare/main...$(git branch --show-current)"
```

### Pre-Creation Workflow

#### Complete Workflow Example
```bash
# 1. Complete your work
git add .
git commit -m "Add delete browsing data to main menu"

# 2. Run contributor analysis
git log --pretty=format:"%an <%ae>" --follow -- path/to/modified/file.swift | sort | uniq -c | sort -nr

# 3. Create PR template file with analysis results
cat > pr-description.md << 'EOF'
Task/Issue URL: https://asana.com/your-task-url
Tech Design URL: 
CC: @alice @bob @charlie

### Description
Adds delete browsing data functionality to the main menu...
[Fill in based on analysis]
EOF

# 4. Push and create PR
git push -u origin feature/delete-browsing-data-menu
gh pr create --title "Add delete browsing data to main menu" --body-file pr-description.md --reviewer @alice
```

### Post-Creation Actions

#### After PR is Created
```bash
# Add additional reviewers if needed
gh pr edit --add-reviewer @username

# Add labels
gh pr edit --add-label "feature" --add-label "ui"

# Add "pending ship review" for UI/interaction changes
gh pr edit --add-label "pending ship review"

# Convert to draft if needed
gh pr ready --undo

# Mark as ready for review
gh pr ready
```

### Troubleshooting

#### Common Issues and Solutions

1. **Template not showing**: Check if repository has `.github/pull_request_template.md`
2. **Reviewer not found**: Ensure GitHub usernames are correct
3. **Permission issues**: Verify you have write access to the repository
4. **Branch protection**: Some branches may require specific approvals
5. **Uncommitted changes warning**: GitHub CLI warns about uncommitted files - this is normal if you have unrelated changes
6. **Branch has no upstream**: Use `-u` flag when pushing to set upstream tracking

#### Branch Upstream Management

**Set upstream during push (recommended):**
```bash
# Sets upstream and pushes in one command
git push -u origin $(git branch --show-current)
# or for specific branch name
git push -u origin your-branch-name
```

**Set upstream for existing branch:**
```bash
# If branch already exists remotely but no upstream set
git branch --set-upstream-to=origin/$(git branch --show-current)
# or
git push --set-upstream origin $(git branch --show-current)
```

**Check upstream status:**
```bash
# See which branches have upstream configured
git branch -vv

# Check current branch upstream
git rev-parse --abbrev-ref $(git branch --show-current)@{upstream}
```

**Fix common upstream issues:**
```bash
# Branch exists locally but not remotely
git push -u origin $(git branch --show-current)

# Branch exists remotely but no upstream tracking
git branch --set-upstream-to=origin/$(git branch --show-current)

# Upstream is set but branch was renamed
git branch -u origin/new-branch-name
```

#### GitHub CLI Debug
```bash
# Check GitHub CLI status
gh auth status

# List available reviewers
gh api repos/duckduckgo/apple-browsers/collaborators --jq '.[].login'

# Check PR status
gh pr list --author @me
```

#### Lessons Learned from Practical Usage

**üö´ Avoid These Pitfalls:**

1. **Multi-line commit messages in tools**: Some tools don't handle newlines well
   ```bash
   # ‚ùå Problematic in some contexts
   git commit -m "Line 1
   Line 2
   Line 3"
   
   # ‚úÖ Use single line or -F flag
   git commit -m "Brief description"
   # or
   git commit -F commit-message.txt
   ```

2. **Creating temporary files unnecessarily**: 
   ```bash
   # ‚ùå Extra steps
   cat > pr-description.md << 'EOF'
   [content]
   EOF
   gh pr create --body-file pr-description.md
   rm pr-description.md
   
   # ‚úÖ Direct approach
   gh pr create --body "content"
   # or
   gh pr create --fill-verbose  # Opens editor
   ```

3. **Manual contributor analysis**: 
   ```bash
   # ‚ùå Manual and error-prone
   git log --pretty=format:"%an <%ae>" --follow -- file.swift
   
   # ‚úÖ Use helper function (see above)
   pr-contributors
   ```

4. **Guessing GitHub usernames**:
   ```bash
   # ‚ùå Guessing based on git names
   # "John Smith" -> "@john-smith" ???
   
   # ‚úÖ Look up actual usernames
   gh api repos/duckduckgo/apple-browsers/collaborators --jq '.[].login' | grep -i john
   ```

**‚úÖ Best Practices:**

1. **Always set upstream when pushing**: Use `git push -u origin branch-name` for new branches
2. **Use interactive mode for complex PRs**: `gh pr create --fill-verbose`
3. **Leverage repository templates**: Let GitHub CLI use existing templates
4. **Add labels immediately**: Include `--label` in creation command
5. **Open in browser**: Use `--web` flag to review and edit in browser
6. **Keep commits atomic**: One logical change per commit makes PR creation easier
7. **Check upstream status**: Use `git branch -vv` to verify tracking branches
